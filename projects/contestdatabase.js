// use strict causes issues.

let database_obj;

//JSON NOTES:
//NUMBERS THAT ARE UNKNOWN DEFAULT TO -1. OTHER UNKNOWNS DEFAULT TO NOTHING

// Common letiables here. USE VAR - NO SUPPORT FOR IE IF LET/CONST USED
const color_motk = "#66AAFF";
const color_locaa = "#66FFAA";
const color_uwom = "#CCCCCC";
const color_bhe = "#e0115f";

const num_locations = 4; // Used in select for loops
const location_names = ["MotK", "LOCAA", "UWoM", "BHE"]; // This allows for for loops. ALL STRUCTURES USE THIS ORDER.
const location_names_lc = ["motk", "locaa", "uwom", "bhe"]; // Valid locations from JSON, in proper order
const location_colors = [color_motk, color_locaa, color_uwom, color_bhe];

const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

const styles = '<style>' +
// Horizontal Text A - used for start anchored text such as key/legend text and participant history partipant names. 10px font.
'.cdb_horiztext_a {font-family: Andale Mono, Monospace; font-size: 10px; fill: #DDDDDD; text-anchor: start; dominant-baseline: central;} ' +
// Horizontal Text B - used for middle anchored text such as axis labels and centered numbers. 14px font.
'.cdb_horiztext_b {font-family: Andale Mono, Monospace; font-size: 14px; fill: #DDDDDD; text-anchor: middle; dominant-baseline: central;} ' + 
// Horizontal Text C - used for end anchored text such as generated by sparen.github.io text. 10px font.
'.cdb_horiztext_c {font-family: Andale Mono, Monospace; font-size: 10px; fill: #DDDDDD; text-anchor: end; dominant-baseline: central;} ' +
// Vertical Text A - used for vertical text. 10px font.
'.cdb_verttext_a {font-family: Andale Mono, Monospace; font-size: 10px; fill: white; text-anchor: middle; dominant-baseline: central; writing-mode: tb;} ' +
// Partipant History Circles
'.cdb_ph_hostcircle {r: 6; stroke: #FF6688; stroke-width: 1; fill: #222222;} ' +
'.cdb_ph_judgecircle {r: 2; fill: #44FFCC;} ' +
'.cdb_ph_topthreecircle {r: 4; fill: #FFCC88;} ' +
'.cdb_ph_partcircle {r: 5; stroke: #FFFFFF; stroke-width: 1; fill: #222222;} ' +
'</style>';


/* ---------- Helper Functions ---------- */
// Returns a SVG rect for the border
function createBorder(height, width) {
    return '<rect x="0" y="0" height="' + height + '" width="' + width + '" fill="#222222" stroke="#CCCCCC" stroke-width="2"></rect>';
}

// Returns a SVG text object with the specified classes and content
function createCDBSVGText(textx, texty, textclass, textcontent) {
    return '<text x="' + textx + '" y="' + texty  + '" class="' + textclass + '">' + textcontent + '</text>';
}

// Returns a SVG circle object with the specified classes
function createCDBSVGCircle(cx, cy, circleclass) {
    // NOTE: Even though we specify the radius as part of the CSS class, whether or not the r attribute is styled properly is entirely up to the browser.
    // Therefore, we will manually force it as an attribute here.
    let tgtrad = 1;
    if (circleclass === 'cdb_ph_hostcircle') {tgtrad = 6}
    else if (circleclass === 'cdb_ph_judgecircle') {tgtrad = 2}
    else if (circleclass === 'cdb_ph_topthreecircle') {tgtrad = 4}
    else if (circleclass === 'cdb_ph_partcircle') {tgtrad = 5}
    return '<circle cx="' + cx + '" cy="' + cy  + '" r="' + tgtrad + '" class="' + circleclass + '"></circle>';
}

// Given the starting x and y coordinates, generates the common key for color-location matching
function generatekey(xstart, ystart) {
    let output = "";
    output += '<rect x="' + (xstart - 96) + '" y="' + (ystart) + '" height="8" width="8" fill="' + color_motk + '"></rect>';
    output += createCDBSVGText(xstart - 80, ystart + 4, "cdb_horiztext_a", "MotK");
    output += '<rect x="' + (xstart - 96) + '" y="' + (ystart + 30) + '" height="8" width="8" fill="' + color_locaa + '"></rect>';
    output += createCDBSVGText(xstart - 80, ystart + 34, "cdb_horiztext_a", "LOCAA");
    output += '<rect x="' + (xstart - 96) + '" y="' + (ystart + 60) + '" height="8" width="8" fill="' + color_uwom + '"></rect>';
    output += createCDBSVGText(xstart - 80, ystart + 64, "cdb_horiztext_a", "UWoM");
    output += '<rect x="' + (xstart - 96) + '" y="' + (ystart + 90) + '" height="8" width="8" fill="' + color_bhe + '"></rect>';
    output += createCDBSVGText(xstart - 80, ystart + 94, "cdb_horiztext_a", "BHE");
    return output;
}

// Given a contest object, returns an object with the start and end dates as well as the color to be used
function fetchstartendcolor(contestobj) {
    let fsec_start = [0, 0]; //year, month (1-12)
    let fsec_end = [0, 0]; //year, month (1-12)
    let cleared = true;
    let displaystring = "";
    fsec_end[0] = Math.trunc(contestobj.duration[1]);
    if (fsec_end[0] === -1) {
        fsec_end[1] = -1;
        displaystring += "Note: Contest ID " + contestobj.id + " does not have a valid end date.<br>";
        cleared = false; //NO GO IF NO END DATE
    } else {
        fsec_end[1] = Math.trunc((contestobj.duration[1] - fsec_end[0]) * 100);
    }
    fsec_start[0] = Math.trunc(contestobj.duration[0]);
    if (fsec_start[0] === -1) {
        fsec_start[1] = -1;
        displaystring += "Note: Contest ID " + contestobj.id + " does not have a valid start date.<br>";
        fsec_start = fsec_end; //so that the rectangle centers on the end date only
    } else {
        fsec_start[1] = Math.trunc((contestobj.duration[0] - fsec_start[0]) * 100);
    }
    //console.log("Start: " + fsec_start + " | End: " + fsec_end);
    let fsec_color = color_motk;
    if (contestobj.location === "locaa") {
        fsec_color = color_locaa;
    } else if (contestobj.location === "uwom") {
        fsec_color = color_uwom;
    } else if (contestobj.location === "bhe") {
        fsec_color = color_bhe;
    }
    return {
        "startval": fsec_start,
        "endval": fsec_end,
        "cleared": cleared,
        "colorval": fsec_color,
        "dstring": displaystring
    };
}

// Returns true if a is in the specified object
function contains(a, obj) {
    let i = a.length;
    while (i--) {
       if (a[i] === obj) {
           return true;
       }
    }
    return false;
}

// Returns true if the player is a participant, host, or judge; false otherwise
function didParticipatePlayer(player, contestobj) {
    return contains(contestobj.participants, player) || contains(contestobj.judges, player) || contestobj.host === player;
}

// Returns the index of the value in the array or -1 if it is not present
function getIndexInArr(val, arr) {
    let giiactr = 0;
    for (giiactr = 0; giiactr < arr.length; giiactr += 1) {
        if (arr[giiactr] === val) {
            return giiactr;
        }
    }
    return -1;
}

// Creates an array with l zeros
function createZeroArray(l) {
    let cza_toreturn = [];
    let czactr = 0;
    for (czactr = 0; czactr < l; czactr += 1) {
        cza_toreturn.push(0);
    }
    return cza_toreturn;
}

// Given a contest object, returns an object containing the following:
// array of years from min to max, zeroed ND array of contests per year, zeroed ND array of partipants per year, first/min year, last/max year
// Zeroed arrays are for convenience's sake and are based on the number of locations available
function getYearArrays(contestobj) {
    let contestctr = 0;
    let yearctr = 0;

    // First, find range of years and prepare arrays accordingly. The output includes skipped years
    let min = contestobj[0].year;
    let max = contestobj[0].year;

    let years = [];
    let cploc = []; //nD array storing contests per year, per location
    let pploc = []; //nD array storing partipants per year, per location
    for (contestctr = 0; contestctr < contestobj.length; contestctr += 1) {
        let temp = contestobj[contestctr].year;
        if (temp > max) {max = temp;}
        if (temp < min && temp !== -1) {min = temp;}
    }
    for (yearctr = min; yearctr <= max; yearctr += 1) {
        years = years.concat([yearctr]);
        cploc = cploc.concat([createZeroArray(num_locations)]);
        pploc = pploc.concat([createZeroArray(num_locations)]);
    }
    return {"years": years, "cploc": cploc, "pploc": pploc, "firstyear": min, "lastyear": max};
}

/* ---------- Primary Operational Functions ---------- */

function contestsPerYear() { //WARNING: NUMBER OF LOCATIONS IS CURRENTLY HARDCODED
    console.log("contestsPerYear(): Running");

    let i = 0;
    let contestctr = 0;
    let yearctr = 0;
    let locationctr = 0;

    let contests = database_obj.contests; //array of contests

    // Get year range array and any related helper data
    let yeararrays = getYearArrays(contests);
    let years = yeararrays.years;
    let values = yeararrays.cploc;

    for (contestctr = 0; contestctr < contests.length; contestctr += 1) {
        let temp = contests[contestctr].year;
        if (contains(years, temp)) { //This statement is necessary for the -1 case
            let tempindex = getIndexInArr(contests[contestctr].location, location_names_lc); // Determine index for location the contest was hosted at
            values[years.indexOf(temp)][tempindex] ++;
        } else if (temp !== -1) { //Failsafe
            alert("ERROR");
        }
    }

    console.log("contestsPerYear(): Preparing Result");
    let displaystring = "";
    for (yearctr = 0; yearctr < years.length; yearctr += 1) {
        let yearsum = 0; // Sum of all contests this year
        displaystring = displaystring + years[yearctr] + " - ";
        for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
            displaystring += location_names[locationctr] + ": " + values[yearctr][locationctr] + "   |   ";
            yearsum += values[yearctr][locationctr];
        }
        displaystring += "Total: " + yearsum + "<br>";
    }

    console.log("contestsPerYear(): Preparing SVG Display"); //NOTE: The SVG height is hardcoded to a max of 23 contests/year
    let cpy_svg_width = 168 + years.length * 16;
    let cpy_svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + cpy_svg_width + '" height="280" version="1.1"' +
        'xmlns:xlink="http://www.w3.org/1999/xlink">' + styles;

    cpy_svg += createBorder(280, cpy_svg_width);
    for (i = 0; i < 6; i += 1) { //lines
        cpy_svg += '<path d="M 48 ' + (230 - i*50) + ' H ' + (cpy_svg_width - 120) + '" stroke="#666666" stroke-width="1" fill="none"></path>';
        cpy_svg += createCDBSVGText(24, 230 - i*50, "cdb_horiztext_b", 5*i);
    }
    // Draw components of bar charts per year, with the total counts as well
    for (yearctr = 0; yearctr < years.length; yearctr += 1) { //paths and text
        let cpy_svg_barbase = 230; // Bottom of bar segment
        let barx = 48 + yearctr*16;
        let yearsum = 0; // Sum of all contests this year
        for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
            let temp_cpy_svg_count = 10*values[yearctr][locationctr];
            cpy_svg += '<path d="M ' + barx + ' ' + (cpy_svg_barbase) + ' V ' + (cpy_svg_barbase - temp_cpy_svg_count) + '" stroke="' + location_colors[locationctr] + '" stroke-width="12" fill="none"></path>';
            cpy_svg_barbase -= temp_cpy_svg_count; // Shift next segment up by current segment's length
            yearsum += values[yearctr][locationctr];
        }

        // Year text
        cpy_svg += createCDBSVGText(barx, cpy_svg_barbase - 10, "cdb_horiztext_b", yearsum);
        cpy_svg += createCDBSVGText(barx, 250, "cdb_verttext_a", years[yearctr]);
    }
    //key
    cpy_svg += generatekey(cpy_svg_width, 96);

    cpy_svg += createCDBSVGText(cpy_svg_width - 4, 280 - 10, "cdb_horiztext_c", "This graph was generated by sparen.github.io");

    cpy_svg += '</svg>';

    document.getElementById("displaybox").innerHTML = displaystring + "<br>" + cpy_svg + 
    "<br><br>Disclaimer: This information may not be up to date, and some contests lack start and/or end dates.<br>" +
    "All contests here are listed by end year. Contests with no date information are not shown.";
}

function averageNumParticipantsLocation() { //WARNING: NUMBER OF LOCATIONS IS CURRENTLY HARDCODED
    console.log("averageNumParticipantsLocation(): Running");

    let i = 0;
    let contestctr = 0;
    let yearctr = 0;
    let locationctr = 0;

    let contests = database_obj.contests; //array of contests

    // Get year range array and any related helper data
    let yeararrays = getYearArrays(contests);
    let years = yeararrays.years;
    let anpl_numcontests = yeararrays.cploc;
    let anpl_numparts = yeararrays.pploc;

    for (contestctr = 0; contestctr < contests.length; contestctr += 1) {
        let temp = contests[contestctr].year;
        if (contains(years, temp)) { //This statement is necessary for the -1 case
            let tempindex = getIndexInArr(contests[contestctr].location, location_names_lc); // Determine index for location the contest was hosted at
            anpl_numcontests[years.indexOf(temp)][tempindex] ++;
            anpl_numparts[years.indexOf(temp)][tempindex] += contests[contestctr].numparticipants;
        } else if (temp !== -1) { //Failsafe
            alert("ERROR");
        }
    }

    //assemble averages
    let anpl_averages = [];
    for (yearctr = 0; yearctr < years.length; yearctr += 1) {
        let temp_avg = [];
        for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
            temp_avg.push((anpl_numparts[yearctr][locationctr]/anpl_numcontests[yearctr][locationctr]).toFixed(2));
            // Checks if a location had zero contests in a year and outputs to console
            if (isNaN(temp_avg[locationctr])) {temp_avg[locationctr] = 0; console.log("anps(): 0 contests at " + years[yearctr] + " at " + location_names[locationctr]);}
        }
        anpl_averages = anpl_averages.concat([temp_avg]);
    }

    console.log("averageNumParticipantsLocation(): Preparing Result");

    let displaystring = "";

    console.log("averageNumParticipantsLocation(): Preparing SVG Display");
    let anpl_svg_width = 168 + years.length * 32;
    let anpl_svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + anpl_svg_width + '" height="320" version="1.1"' +
        'xmlns:xlink="http://www.w3.org/1999/xlink">' + styles;
        //border

    anpl_svg += createBorder(320, anpl_svg_width);
    for (i = 0; i < 6; i += 1) { //lines
        anpl_svg += '<path d="M 48 ' + (270 - i*50) + ' H ' + (anpl_svg_width - 120) + '" stroke="#666666" stroke-width="1" fill="none"></path>';
        anpl_svg += createCDBSVGText(24, 270 - i*50, "cdb_horiztext_b", 5*i);
    }

    // Plot line segments for the path
    for (yearctr = 0; yearctr < years.length - 1; yearctr += 1) {
        for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
            let anpl_start = 10*anpl_averages[yearctr][locationctr]; // start of path segment
            let anpl_end = 10*anpl_averages[yearctr + 1][locationctr]; // end of path segment
            anpl_svg += '<path d="M ' + (48 + yearctr*32) + ' ' + (270 - anpl_start) + ' L ' + (48 + (yearctr+1)*32) + ' ' + (270 - anpl_end) + '" stroke="' + location_colors[locationctr] + '" stroke-width="2" fill="none"></path>';
        }
    }
    // Plot points and years
    for (yearctr = 0; yearctr < years.length; yearctr += 1) {
        for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
            let anpl_start = 10*anpl_averages[yearctr][locationctr]; // location of point to plot
            anpl_svg += '<circle cx="' + (48 + yearctr*32) + '" cy="' + (270 - anpl_start) + '" r="2" stroke="white" stroke-width="0.5" fill="' + location_colors[locationctr] + '"></circle>';
        }
        // Now add text for years
        anpl_svg += createCDBSVGText(48 + yearctr*32, 290, "cdb_verttext_a", years[yearctr]);
    }

    //key
    anpl_svg += generatekey(anpl_svg_width, 96);

    anpl_svg += createCDBSVGText(anpl_svg_width - 4, 320 - 10, "cdb_horiztext_c", "This graph was generated by sparen.github.io");

    anpl_svg += '</svg>';

    //OVERALL STATS
    let displaystring2 = "";
    for (locationctr = 0; locationctr < num_locations; locationctr += 1) {
        let anpl_totalnumcontests = 0; // Number of contests in this category
        let anpl_totalnumparts = 0; // Number of participants in this category
        for (yearctr = 0; yearctr < years.length; yearctr += 1) {
            anpl_totalnumcontests +=  anpl_numcontests[yearctr][locationctr];
            anpl_totalnumparts += anpl_numparts[yearctr][locationctr];
        }
        let anpl_overallaverage = (anpl_totalnumparts/anpl_totalnumcontests).toFixed(2);
        displaystring2 += location_names[locationctr] + " Overall: " + anpl_overallaverage + " participants/contest<br>";
    }

    document.getElementById("displaybox").innerHTML = displaystring + "<br>" + anpl_svg + "<br>" + displaystring2;
}

function participantsOverTime() { //WARNING: NUMBER OF LOCATIONS IS CURRENTLY HARDCODED
    console.log("participantsOverTime(): Running");

    let i = 0;
    let contestctr = 0;
    let monthctr = 0;
    let yearctr = 0;
    let locationctr = 0;

    let contests = database_obj.contests; //array of contests

    // Get year range array and any related helper data
    let yeararrays = getYearArrays(contests);
    let years = yeararrays.years;
    let min = yeararrays.firstyear;

    //Now that we know how big the graph is going to be, let's begin setting up the graph. First, the grid
    console.log("participantsOverTime(): Preparing SVG Display");
    let pot_svg_width = 168 + years.length * 32 * 6;
    let pot_svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + pot_svg_width + '" height="400" version="1.1"' +
        'xmlns:xlink="http://www.w3.org/1999/xlink">' + styles;
        //border

    pot_svg += createBorder(400, pot_svg_width);
    for (i = 0; i < 7; i += 1) { //lines
        pot_svg += '<path d="M 48 ' + (320 - i*50) + ' H ' + (pot_svg_width - 120) + '" stroke="#666666" stroke-width="1" fill="none"></path>';
        pot_svg += createCDBSVGText(24, 320 - i*50, "cdb_horiztext_b", 5*i);
    }

    //Now let's plot the timestamps. The years are 32*6 pixels apart. So that means 16 pixels per month.
    for (yearctr = 0; yearctr < years.length; yearctr += 1) { //years
        for (monthctr = 0; monthctr < 12; monthctr += 1) {
            pot_svg += createCDBSVGText(48 + yearctr * 32 * 6 + monthctr * 16, 400 - 50, "cdb_verttext_a", months[monthctr] + " " + years[yearctr]);
        }
    }

    //Now the key.
    pot_svg += generatekey(pot_svg_width, 131);

    pot_svg += createCDBSVGText(pot_svg_width - 4, 400 - 10, "cdb_horiztext_c", "This graph was generated by sparen.github.io");

    //And now, the data points. Rectangles will be used here.
    let displaystring = ""; //to log when contest data is unknown
    let textlabels = ""; //so that all text rendered on a higher layer
    for (contestctr = 0; contestctr < contests.length; contestctr += 1) { //for each contest
        let results = fetchstartendcolor(contests[contestctr]);
        let pot_start = results.startval;
        let pot_end = results.endval;
        let cleared = results.cleared;
        let pot_color = results.colorval;
        displaystring = displaystring + results.dstring;
        let pot_participants = contests[contestctr].numparticipants; //for height

        //Now create the SVG rectangle iff there is an end date
        if (cleared) {
            let pot_basestart = ((pot_start[0]-min)*12 + pot_start[1])*16; //does not include 48 pixel left and 4 pixel buffer
            let pot_basewidth = ((pot_end[0] - pot_start[0])*12 + pot_end[1] - pot_start[1])*16; //does not include 8 pixel base rect width
            pot_svg += '<rect x="' + (48 + pot_basestart - 4) + '" y="' + (320 - (pot_participants * 10)) + 
            '" height="' + (pot_participants * 10) + '" width="' + (8 + pot_basewidth) + '" fill="' + pot_color + '" fill-opacity="0.75"></rect>';
            textlabels += '<text x="' + (48 + pot_basestart + pot_basewidth/2) + '" y="' + (320 - (pot_participants * 10)) + 
            '" fill="' + pot_color + '" text-anchor="end" dominant-baseline="central" writing-mode="tb" font-family="Andale Mono, Monospace" font-size="10px">' + contests[contestctr].id + '</text>';
        }
    }

    pot_svg += textlabels; //labels with contest ID

    pot_svg += '</svg>';

    document.getElementById("displaybox").innerHTML = displaystring + pot_svg + "<br><br>Contests without a valid end date are not displayed. Contests without a valid start date only show their end month and year.";
}

function participantHistory() {
    console.log("participantHistory(): Running");

    let i = 0;
    let contestctr = 0;
    let judgectr = 0;
    let participantctr = 0;

    let allparticipants = [];
    let contests = database_obj.contests; //array of contests

    let ph_displaystring = "Please select people from the following lists in order to generate histories.<br><br>" + 
    "This feature allows you to select any number of participants, and a chart will be generated showing their participation, top three placement, and judging and hosting history over the span of multiple contests.<br><br>";

    ph_displaystring = ph_displaystring + "<form method='POST' onSubmit='return participantHistory_graphgen();'><input type='SUBMIT' value='Generate Histories'></form>";
    ph_displaystring = ph_displaystring + '<input type="checkbox" name="ph_controlmaster" defaultChecked="false" onclick="return participantHistory_toggleall(this, this.checked);"> Toggle All<br><br>';

    //first, obtain list of all chartable people
    for (contestctr = 0; contestctr < contests.length; contestctr += 1) {
        let ph_judges = contests[contestctr].judges;
        let ph_host = contests[contestctr].host;
        let ph_participants = contests[contestctr].participants;

        //For obtaining all participants, dropdown list
        let ph_temp;
        for (judgectr = 0; judgectr < ph_judges.length; judgectr += 1) {
            ph_temp = ph_judges[judgectr];
            if (!contains(allparticipants, ph_temp)) {
                allparticipants = allparticipants.concat(ph_temp);
            }
        }
        if (!contains(allparticipants, ph_host)) {
            allparticipants = allparticipants.concat(ph_host);
        }
        for (participantctr = 0; participantctr < ph_participants.length; participantctr += 1) {
            ph_temp = ph_participants[participantctr];
            if (!contains(allparticipants, ph_temp)) {
                allparticipants = allparticipants.concat(ph_temp);
            }
        }

        //for listings by contest
        let contestdisplay = "<div>" + contests[contestctr].id + ": " + contests[contestctr].name + "</div>";
        contestdisplay = contestdisplay + '<input type="checkbox" name="ph_control" defaultChecked="false" onclick="return participantHistory_selectbycontest(\'' + contests[contestctr].id + '\', this, this.checked);"> Check All<br>';
        if (ph_host !== "") {
            contestdisplay = contestdisplay + "Host: " + '<input type="checkbox" name="ph_participant" class="ph_' + contests[contestctr].id + '" id="' + ph_host + '" defaultChecked="false">' + ph_host + '<br>';
        } else {
            contestdisplay = contestdisplay + "Host: N/A" + '<br>';
        }
        contestdisplay = contestdisplay + "Judges: <br>";
        for (judgectr = 0; judgectr < ph_judges.length; judgectr += 1) {
            ph_temp = ph_judges[judgectr];
            if (ph_temp !== "COMMUNITY" && ph_temp !== "GUEST" && ph_temp !== "") {
                contestdisplay = contestdisplay + '&nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" name="ph_participant" class="ph_' + contests[contestctr].id + '" id="' + ph_temp + '" defaultChecked="false">' + ph_temp + '<br>';
            } else {
                contestdisplay = contestdisplay + '&nbsp;&nbsp;&nbsp;&nbsp;' + ph_temp + '<br>';
            }
        }
        contestdisplay = contestdisplay + 'Participants: <br><table style="width:100%"><tr>'; //DON'T SHOW THE MISSHAPEN BORDER PLZ
        for (participantctr = 0; participantctr < ph_participants.length; participantctr += 1) {
            ph_temp = ph_participants[participantctr];
            contestdisplay = contestdisplay + '<td><input type="checkbox" name="ph_participant" class="ph_' + contests[contestctr].id + '" id="' + ph_temp + '" defaultChecked="false">' + ph_temp + '</td>';
            if (participantctr % 5 === 4) { // Show five per line
                contestdisplay = contestdisplay + '</tr><tr>';
            }
        }
        for (participantctr = ph_participants.length; participantctr % 5 !== 0; participantctr += 1) { //buffer space
            contestdisplay = contestdisplay + '<td></td>';
        }
        contestdisplay = contestdisplay + "</tr></table>";

        ph_displaystring = ph_displaystring + contestdisplay;
    }
    document.getElementById("displaybox").innerHTML = ph_displaystring;

}

function participantHistory_selectbycontest(contestid, parent, newval) {
    console.log("participantHistory_selectbycontest(): Running");
    let ph_checked = document.getElementsByClassName("ph_" + contestid);
    let parthistctr = 0;
    for (parthistctr = 0; parthistctr < ph_checked.length; parthistctr += 1) {
        ph_checked[parthistctr].checked = newval;
    }
    parent.checked = newval; //Some weird error where it stays unchecked when you check it. whelp.
    return false;
}

function participantHistory_toggleall(parent, newval) {
    console.log("participantHistory_toggleall(): Running");
    let ph_checked = document.getElementsByName("ph_participant");
    let parthistctr = 0;
    for (parthistctr = 0; parthistctr < ph_checked.length; parthistctr += 1) {
        ph_checked[parthistctr].checked = newval;
    }
    parent.checked = newval; //Some weird error where it stays unchecked when you check it. whelp.
    return false;
}

function participantHistory_graphgen() { //call with a button call
    console.log("participantHistory_graphgen(): Running");

    let i = 0;
    let contestctr = 0;
    let monthctr = 0;
    let yearctr = 0;
    let locationctr = 0;
    let judgectr = 0;
    let participantctr = 0;
    let parthistctr = 0;

    //Read and obtain all selected names
    let ph_checked = document.getElementsByName("ph_participant");
    let phgg_selpartic = []; // List of selected participants
    for (parthistctr = 0; parthistctr < ph_checked.length; parthistctr += 1) {
        let phggtemp = ph_checked[parthistctr].id;
        if (!contains(phgg_selpartic, phggtemp) && ph_checked[parthistctr].checked) {
            phgg_selpartic = phgg_selpartic.concat(phggtemp);
        }
    }

    //Prepare SVG using Participants over Time as the base
    let contests = database_obj.contests; //array of contests

    // Get year range array and any related helper data
    let yeararrays = getYearArrays(contests);
    let years = yeararrays.years;
    let min = yeararrays.firstyear;

    console.log("participantHistory_graphgen(): Preparing SVG Display");
    let phgg_svg_width = 264 + years.length * 32 * 6;
    let phgg_svg_height = 164 + 16 * phgg_selpartic.length;
    let phgg_svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + phgg_svg_width + '" height="' + phgg_svg_height + '" version="1.1"' +
        'xmlns:xlink="http://www.w3.org/1999/xlink">' + styles;
        //border

    phgg_svg += createBorder(phgg_svg_height, phgg_svg_width);

    //Now let's plot the timestamps. The years are 32*6 pixels apart. So that means 16 pixels per month.
    //144 is the buffer on the left (for names). 128 is the buffer on the right (for the key)
    for (yearctr = 0; yearctr < years.length; yearctr += 1) { //years
        for (monthctr = 0; monthctr < 12; monthctr += 1) {
            phgg_svg += createCDBSVGText(144 + yearctr*32*6 + monthctr*16, (phgg_svg_height - 108), "cdb_verttext_a", months[monthctr] + " " + years[yearctr]);
        }
    }

    //Now the key.
    let keycirclex = (phgg_svg_width - 96);
    let keytextx = (phgg_svg_width - 80);
    phgg_svg += createCDBSVGCircle(keycirclex, (phgg_svg_height/2 - 50), "cdb_ph_hostcircle");
    phgg_svg += createCDBSVGText(keytextx, (phgg_svg_height/2 - 50), "cdb_horiztext_a", "Host");
    phgg_svg += createCDBSVGCircle(keycirclex, (phgg_svg_height/2 - 20), "cdb_ph_judgecircle");
    phgg_svg += createCDBSVGText(keytextx, (phgg_svg_height/2 - 20), "cdb_horiztext_a", "Judge");
    phgg_svg += createCDBSVGCircle(keycirclex, (phgg_svg_height/2 + 10), "cdb_ph_topthreecircle");
    phgg_svg += createCDBSVGText(keytextx, (phgg_svg_height/2 + 10), "cdb_horiztext_a", "Top 3");
    phgg_svg += createCDBSVGCircle(keycirclex, (phgg_svg_height/2 + 40), "cdb_ph_partcircle");
    phgg_svg += createCDBSVGText(keytextx, (phgg_svg_height/2 + 40), "cdb_horiztext_a", "Participant");

    phgg_svg += createCDBSVGText(phgg_svg_width - 4, phgg_svg_height - 10, "cdb_horiztext_c", "This graph was generated by sparen.github.io");

    //And now, the data points. Rectangles will be used here.
    let displaystring = ""; //to log when contest data is unknown
    let textlabels = ""; //so that all text rendered on a higher layer
    for (contestctr = 0; contestctr < contests.length; contestctr += 1) { //for each contest
        let results = fetchstartendcolor(contests[contestctr]);
        let phgg_start = results.startval;
        let phgg_end = results.endval;
        let cleared = results.cleared;
        let phgg_color = results.colorval;
        displaystring = displaystring + results.dstring;

        //Now create the SVG rectangle iff there is an end date
        if (cleared) {
            let phgg_basestart = ((phgg_start[0]-min)*12 + phgg_start[1])*16; //does not include 144 pixel left and 4 pixel buffer
            let phgg_basewidth = ((phgg_end[0] - phgg_start[0])*12 + phgg_end[1] - phgg_start[1])*16; //does not include 8 pixel base rect width
            textlabels += '<text x="' + (144 + phgg_basestart + phgg_basewidth/2) + '" y="' + (phgg_svg_height - 80) + 
            '" fill="' + phgg_color + '" text-anchor="start" dominant-baseline="central" writing-mode="tb" font-family="Andale Mono, Monospace" font-size="10px">' + contests[contestctr].id + '</text>';
            textlabels += '<path d="M' + (144 + phgg_basestart + phgg_basewidth/2) + ' 4 V' + (phgg_svg_height - 156) + '" stroke-width="1" stroke="#333333"></path>'; //contest guideline
        }
    }

    phgg_svg += textlabels; //labels with contest ID

    //Now it's time to add the participants! Oh boy what a... uh... treat!
    for (participantctr = 0; participantctr < phgg_selpartic.length; participantctr += 1) { //for each and every player.
        let phgg_curry = 16 + participantctr*16;
        let phgg_player = phgg_selpartic[participantctr];
        let phggplay_start = 0; //start pixel of line
        let phggplay_end = 0; //end pixel of line
        let phgg_string = createCDBSVGText(8, phgg_curry, "cdb_horiztext_a", phgg_player);
        let phgg_startendpath = '<path d="M 4 ' + (phgg_curry - 8) + ' H ' + (phgg_svg_width - 128) + '" stroke-width="1" stroke="#333333"></path>'; //default guide lines
        phgg_startendpath = phgg_startendpath + '<path d="M 4 ' + (phgg_curry + 8) + ' H ' + (phgg_svg_width - 128) + '" stroke-width="1" stroke="#333333"></path>'; //default guide lines
        let phgg_nodes = "";

        //Now to iterate over all the contests in search of the name!
        for (contestctr = 0; contestctr < contests.length; contestctr += 1) { //for each contest
            let contestobj = contests[contestctr];
            let phggindiv_results = fetchstartendcolor(contests[contestctr]);
            let phggindiv_start = phggindiv_results.startval;
            let phggindiv_end = phggindiv_results.endval;
            let phgg_basestart = ((phggindiv_start[0] - contests[0].year)*12 + phggindiv_start[1])*16; //does not include 144 pixel left and 4 pixel buffer
            let phgg_basewidth = ((phggindiv_end[0] - phggindiv_start[0])*12 + phggindiv_end[1] - phggindiv_start[1])*16; //does not include 8 pixel base rect width
            let nodelocation = 144 + phgg_basestart + phgg_basewidth/2;

            if (contains(contestobj.participants, phgg_player) || contains(contestobj.judges, phgg_player) || contestobj.host === phgg_player) {
                if (phggplay_start > nodelocation || phggplay_start === 0) {phggplay_start = nodelocation;} //if first contest, mark it!
                if (contestobj.host === phgg_player) {
                    phgg_nodes += createCDBSVGCircle(nodelocation, phgg_curry, "cdb_ph_hostcircle");
                }
                if (contains(contestobj.participants, phgg_player)) {
                    phgg_nodes += createCDBSVGCircle(nodelocation, phgg_curry, "cdb_ph_partcircle");
                }
                let topthree = false;
                let k = 0;
                for (k = 0; k < contestobj.result.length; k += 1) {
                    if (contains(contestobj.result[k], phgg_player)) {
                        topthree = true;
                    }
                }
                if (topthree) {
                    phgg_nodes += createCDBSVGCircle(nodelocation, phgg_curry, "cdb_ph_topthreecircle");
                }
                if (contains(contestobj.judges, phgg_player)) {
                    phgg_nodes += createCDBSVGCircle(nodelocation, phgg_curry, "cdb_ph_judgecircle");
                }
                if (phggplay_end < nodelocation) {phggplay_end = nodelocation;} //if first contest, mark it!
            }
        }
        phgg_startendpath = phgg_startendpath + '<path d="M ' + phggplay_start + ' ' + phgg_curry + ' H ' + phggplay_end + '" stroke-width="1" stroke="#666666"></path>';

        if (phgg_player !== "") { //Exclude NULL players - i.e. no judge for a contest
            phgg_svg = phgg_svg + phgg_string;
            phgg_svg = phgg_svg + phgg_startendpath;
            phgg_svg = phgg_svg + phgg_nodes;
        }
    }

    phgg_svg += '</svg>';

    document.getElementById("displaybox").innerHTML = phgg_svg + "<br><br>Contests without a valid end date are not displayed. Contests without a valid start date only show their end month and year.";

    return false;
}

/* ---------- User-Facing and File Utility Functions ---------- */

// Create dropdown menu for query box, providing options to run other functions
function createDropdown() {
    console.log("createDropdown(): Running");
    return "<form method='POST' onSubmit='return execute();'>" +
            "<select id='dropdown'>" +
            "<option value='none' name='opt'> - Please make a selection - </option>" +
            "<option value='cpy' name='opt'>Contests per Year</option>" +
            "<option value='avgnumpartloc' name='opt'>Avg. Num. of Participants by Loc.</option>" +
            "<option value='participateovertime' name='opt'>Participants Over Time</option>" +
            "<option value='participanthistory' name='opt'>Participant History</option>" +
            "</select>" +
            "<input type='SUBMIT' value='Submit'>" +
            "</form>";
}

// Obtains the contents of the specified JSON file
function getFileContents() {
    console.log("getFileContents(): Running");
    let filepath = "contestdatabase.json";
    let client = new XMLHttpRequest();
    client.open("GET", filepath, true);
    client.onreadystatechange = function () { //callback
        if (client.readyState === 4) {
            if (client.status === 200 || client.status === 0) {
                document.getElementById("queryselect").innerHTML = createDropdown();
                database_obj = JSON.parse(client.responseText);
            }
        }
    };

    client.send();
    console.log("getFileContents(): Request Sent");
}

function execute() {
    console.log("execute(): Running");
    let s = "none";
    let selectdd = document.getElementById("dropdown");
    let index = selectdd.selectedIndex;
    s = selectdd.options[index].value;

    console.log("execute(): Checking Selection");

    if (s === "none") {
        document.getElementById("displaybox").innerHTML = "Please make a selection.";
    }

    if (s === "cpy") {
        contestsPerYear();
    } else if (s === "avgnumpartloc") {
        averageNumParticipantsLocation();
    } else if (s === "participateovertime") {
        participantsOverTime();
    } else if (s === "participanthistory") {
        participantHistory();
    }

    console.log("execute(): End");

    return false;
}